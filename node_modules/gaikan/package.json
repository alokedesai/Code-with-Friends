{
  "name": "gaikan",
  "version": "1.3.13",
  "description": "HTML template engine for Node and Express.",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Deathspike/Gaikan.git"
  },
  "keywords": [
    "express",
    "gaikan",
    "template",
    "view",
    "engine"
  ],
  "author": {
    "name": "Roel van Uden"
  },
  "license": "MIT",
  "readme": "# Gaikan (1.3)\r\n\r\nGaikan is a HTML template engine for Node and Express. It allows compilation of HTML to JavaScript and provides a HTML-valid syntax to enable usage of conditions, iterators, includes, partials and variables. The template module was written to have a low entry barrier while accommodating any templating need with the highest achievable performance.\r\n\r\n<a name=\"a1\" />\r\n## Installation\r\n\r\n\t$ npm install gaikan\r\n\r\n<a name=\"a2\"/>\r\n## Features\r\n\r\n\t- Compiles HTML to JavaScript; low entry barrier.\r\n\t- Complies with W3C standards; designer friendly.\r\n\t- Complies with the Express view system.\r\n\t- Includes/partials; share markup between views.\r\n\t- Iterators/conditions; iterate, filter and write conditions.\r\n\t- Variables/handlers; use (conditional) variables and handlers.\r\n\t\r\n<a name=\"a3\"/>\r\n## API\r\n\r\nDirect usage of the API is not required when using [Express](#a4). The following API is available:\r\n\r\n\tcompile(template, compress)\r\n\t    Compiles a template.\r\n\tcompileFile(file, directory, cache, compress)\r\n\t    Compiles a template from file.\r\n\texplain(template, cb)\r\n\t    Explain a template using the compiled function.\r\n\texplainFile(file, directory, cb)\r\n\t    Explain a template from file using the compiled function.\r\n\trender(root, inputPartials, template)\r\n\t    Render a template.\r\n\trenderFile(root, inputPartials, file, directory, cache)\r\n\t    Render a template from file.\r\n\r\n<a name=\"a4\"/>\r\n## Express\r\n\r\nSupport for Express has been made as painless as possible. Include the module:\r\n\r\n\tvar gaikan = require('gaikan').\r\n\r\nConfigure the view engine:\r\n\r\n\tapp.engine('html', gaikan);\r\n\t\r\nSet the view engine extension:\r\n\r\n\tapp.set('view engine', 'html');\r\n\r\n<a name=\"a5\"/>\r\n## Options\r\n\r\nThe following options are available:\r\n\r\n\tcache     : Indicates whether templates compiled from file are cached.\r\n\tcompress  : Indicates whether templates compiled from file are cached.\r\n\tdirectory : The default directory, or directories, used when compiling a template from file.\r\n\textension : The default file extension used when compiling a template from file.\r\n\tlayout    : The layout applied on templates rendered from file.\r\n\tpartial   : The name of the partial used when applying the layout.\r\n\tscoped    : Indicates whether Express rendering is scoped to locals and options as partial.\r\n\r\nThe latter three options are handled in depth at [layouts](#a11) and [scoping](#a12).\r\n\r\n<a name=\"a6\"/>\r\n## Attributes\r\n\r\nThe syntax uses **data-*** attributes for control flow features.\r\n\r\n<a name=\"a7\"/>\r\n### Conditions\r\n\r\nA condition is an if-statement on a HTML element using **data-if**. Use the following template:\r\n\r\n\t<div data-if=\"data.name\">Name is set!</div>\r\n\t\r\nThe **data.name** indicates it uses the current data object with the name property. This is the representation:\r\n\r\n\tresult += '<div>;\r\n\tif (data.name) result += 'Name is set!';\r\n\tresult += '</div>';\r\n\t\r\nWhen not using Express, this is how it would be rendered:\r\n\r\n\tgaikan.renderFile({name: 'Deathspike'}, null, 'template');\r\n\r\nThe second argument is for [partials](#a10), so use null. The result is the following:\r\n\r\n\t<div>Name is set!</div>\r\n\t\r\nConditions are JavaScript, so valid JavaScript is valid here. What if the name is undefined? The result is the following:\r\n\r\n\t<div></div>\r\n\t\r\nThe empty **div** element is there because it was declared. We can use the special element, **ins**, like this:\r\n\r\n\t<ins data-if=\"data.name\">Name is set!</ins>\r\n\r\nUsing the **data-*** attributes, the **ins** element is interpreted as obsolete. This would result in:\r\n\r\n\tName is set!\r\n\t\r\nThe special **ins** element is often useful for [includes](#a9).\r\n\r\n<a name=\"a8\"/>\r\n### Iterators\r\n\r\nAn iterator is a for-statement on a HTML element using **data-in** or **data-for**. Use the following template:\r\n\r\n\t<ul data-in=\"data.users\">\r\n\t\t<li>Someone is here.</li>\r\n\t</ul>\r\n\t\r\nThis is the representation:\r\n\r\n\tresult += '<ul>';\r\n\tfor (var key in data.users) {\r\n\t\tresult += '<li>Someone is here.</li>';\r\n\t}\r\n\tresult += '</ul>';\r\n\r\nWhen not using Express, this is how it would be rendered:\r\n\r\n\tgaikan.renderFile({users: ['Deathspike']}, null, 'template');\r\n\r\nThe result is the following:\r\n\r\n\t<ul><li>Someone is here.</li></ul>\r\n\r\nA for-in statement is not good for performance, so for an array **data-for** is much better:\r\n\r\n\t<ul data-for=\"data.users\">\r\n\t\t<li>Someone is here.</li>\r\n\t</ul>\r\n\r\nThis is the representation:\r\n\r\n\tresult += '<ul>';\r\n\tfor (var key = 0, len = data.users.length; key < len; key++) {\r\n\t\tresult += '<li>Someone is here.</li>';\r\n\t}\r\n\tresult += '</ul>';\r\n\t\r\nThis becomes powerful when used together with [variables](#a13).\r\n\r\n<a name=\"a9\"/>\r\n### Includes\r\n\r\nIncluding allows a template to use another template using **data-include**. The following is **hello.html**:\r\n\r\n\t<b>Hello world!</b>\r\n\t\r\nTo demonstrate an inclusion, the following is **layout.html**:\r\n\r\n\t<div class=\"container\" data-include=\"hello\"></div>\r\n\t\r\nWhen rendering **layout.html**, the output is as followed:\r\n\r\n\t<div class=\"container\"><b>Hello world!</b></div>\r\n\r\nThe contents of **hello.html** are where they are supposed to be.\r\n\r\n<a name=\"a10\"/>\r\n### Partials\r\n\r\nPartials can be used to define and insert content using **data-partial**. The following is **hello.html**:\r\n\r\n\t<b><ins data-partial=\"content\" /></b>\r\n\t\r\nA placeholder has been defined. When including this file, it can be filled. The following is **layout.html**:\r\n\r\n\t<div class=\"container\" data-include=\"hello\">\r\n\t    <ins data-partial=\"content\">\r\n\t        Hello world!\r\n\t    </ins>\r\n\t</div>\r\n\r\nWhen rendering **layout.html**, the output is as followed:\r\n\r\n\t<div class=\"container\"><b>Hello world!</b></div>\r\n\r\nThe result is similar, but note that **Hello world!** was defined in **layout.html** instead of **hello.html**.\r\n\r\n<a name=\"a11\"/>\r\n### Layout\r\n\r\nIncludes and partials can be used to create a layout, but options make it easier. The following is **layout.html**:\r\n\r\n\t<div class=\"container\" data-partial=\"content\"></div>\r\n\t\r\nThe partial placeholder is named content, matching *options.partial*. The following is **hello.html**:\r\n\r\n\t<b>Hello world!</b>\r\n\t\r\nThere are no includes, instead we set *options.layout* to **'layout'**. The output is as followed:\r\n\r\n\t<div class=\"container\"><b>Hello world!</b></div>\r\n\r\nThe **layout** options is very powerful, yet uses standard includes/partials to implement the feature.\r\n\r\n<a name=\"a12\"/>\r\n### Scoping\r\n\r\nHave you been wondering about what **data** really is? It changes depending on the scope. Use the following:\r\n\r\n\t<ul data-each=\"data.users\">\r\n\t\t<li data-if=\"data\">Someone is here.</li>\r\n\t</ul>\r\n\r\nThe condition is using the value from the **data.users** iteration. This is the representation:\r\n\r\n\tresult += '<ul>';\r\n\tfor (var key in data.users) {\r\n\t\t(function (parent, data) {\r\n\t\t\tresult += '<li>Someone is here.</li>';\r\n\t\t})(data, data.users[key]);\r\n\t}\r\n\tresult += '</ul>';\r\n\r\nThe contents of the iteration have been scoped. You can define scoping for **includes** or **partials** as followed:\r\n\r\n\t<div data-include=\"hello|data.contents\">\r\n\t\r\nWhich can be interpreted as the following JavaScript:\r\n\r\n\t(function (data) {\r\n\t\tmagicalGaikanInclude(data, 'hello'); // FYI, this function was made up.\r\n\t})(data.contents);\r\n\r\nScoping enables **key** (in iterations), **parent** (in iterations) and **root**. [Express](#a4) can be scoped as well:\r\n\r\n\tres.locals.value = 'Something';\r\n\tres.render('template', {value: 42});\r\n\t\r\nThe **locals** can be set anywhere, which is what we want for the **layout**. The following is desired:\r\n\r\n\t{value: 'Something', content: {value: 42}}\r\n\t\r\nAnd can be achieved by enabling *options.scoped*. Remind yourself to adjust the scoping of the content partial as well.\r\n\r\n<a name=\"a13\"/>\r\n## Variables\r\n\r\nVariables are defined as either *#{x}* or *!{x}* and are used for content insertion. Use the following:\r\n\r\n\t<b>#{data.name}</b>\r\n\t\r\nThis is the representation:\r\n\r\n\tresult += '<b>' + handlers.escape(data.name) + '</b>';\r\n\r\nSomething strange appeared, *handlers.escape*. That is because a **#** variable is **escaped**. Use the following:\r\n\r\n\t<b>!{data.name}</b>\r\n\r\nSince is the **unescaped** variable, this is the following in JavaScript:\r\n\r\n\tresult += '<b>' + data.name + '</b>';\r\n\r\nAn unescaped variable does allow HTML and is often undesirable. Variables can also use handlers as followed:\r\n\r\n\t#{data|lower}\r\n\t\r\nThis would change the variable to lower-case prior to escaping it. Handlers can be chained as followed:\r\n\r\n\t#{data|lower,upper}\r\n\t\r\nWhich would use both handlers. More information about handlers [can be found here](#a15).\r\n\r\n<a name=\"a14\"/>\r\n### Performance\r\n\r\nAbout 85% of performance loss is due to escaping. A solution is to pre-save escape content:\r\n\r\n\tvar escape = require('gaikan/lib/handlers/escape-handler');\r\n\tvar value = escape('<p>This is escaped</p>');\r\n\t\r\nThis value would result into the following escaped text for storage purposes:\r\n\r\n\t&#60;p&#62;This is escaped&#60;/p&#62;\r\n\r\nThis improves performance as escaping is done once, opposed to every render. The following can be used now:\r\n\r\n\t<b>!{data.content}</b>\r\n\r\nHowever, it is possible that the variable is to be changed. It can be unescaped using a handler as followed:\r\n\r\n\t<textarea>!{data.content|unescape}</textarea>\r\n\t\r\nForgetting to escape a value makes you vulnerable to XSS. A different approach is presented in [a love story](#a16).\r\n\r\n<a name=\"a15\"/>\r\n## Code Injection\r\n\r\nCode can be injected and evaluated at run-time with **@{x}**, similar to the variable prefix:\r\n\r\n\t@{data.name}\r\n\t\r\nA variable would check if this is undefined and then would use a blank string. A more useful example:\r\n\t\r\n\t<option value=\"1\" @{data.score === 1 ? \"selected\" : \"\"}>First Option</option>\r\n\t\r\nCode injection allowed insertation of the 'selected' attribute. Consider this:\r\n\r\n\t@{console.log(data)}\r\n\t\r\nWhich will evaluate and print to the console. Code injection solves hard-to-solve templating with ease.\r\n\r\n<a name=\"a16\"/>\r\n## Filters and Handlers\r\n\r\nHandlers have been explained in [variables](#a13), however the following is also possible:\r\n\r\n\t<div data-if=\"handlers.upper(data.value)[0]\"></div>\r\n\r\nThis is because each handler is a field in the handlers object. The following handlers are available:\r\n\r\n\t* escape: Escapes html to avoid html injection. Default behaviour when using #{var} instead of !{var}.\r\n\t* lower: Changes the value to lower case.\r\n\t* nl2br: Changes new lines to break elements. Great when using !{var|nl2br,escape} for text inputs.\r\n\t* title: Changes the value to title case.\r\n\t* unescape: Unescapes escaped html.\r\n\t* upper: Changes the value to upper case.\r\n\t* url: Escapes the value for use in an url.\r\n\r\nFilters can be used to filter a value for iteration or for a condition.\r\n\r\n\t* isEmpty: Checks if the value is empty. Properties of objects are checked, or length of an array.\r\n\t* sort: Sorts the value. Can be used with reverse and a sorting key for objects in arrays.\r\n\t\r\nAn example of sort as followed:\r\n\r\n\t<div data-each=\"filters.sort(data.users)\">\r\n\t\r\nSorting can be reversed as followed:\r\n\r\n\t<div data-each=\"filters.sort(data.users, true)\">\r\n\t\r\nOr when provided with an array of objects, based on a key, as followed:\r\n\r\n\t<div data-each=\"filters.sort(data.users, 'name')\">\r\n\t\r\nOr both, as shown below:\r\n\r\n\t<div data-each=\"filters.sort(data.users, true, 'name')\">\r\n\r\nEvery filter and handle is accessible in every attribute or variable.\r\n\r\n<a name=\"a17\"/>\r\n## A love story; AJAJ, Express and Gaikan\r\n\r\nGaikan release 1.4 implements the client-side rendering framework; a love story between AJAJ, Express and Gaikan.\r\n\r\n<a name=\"a17\"/>\r\n## Conclusion\r\n\r\nGaikan was written by Roel \"Deathspike\" van Uden. If you have comments, questions or suggestions I would love to hear from you! To contact me, you can send me an e-mail. Thank you for your interest in the Gaikan HTML template engine for Node and Express.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Deathspike/Gaikan/issues"
  },
  "_id": "gaikan@1.3.13",
  "_from": "gaikan@"
}
